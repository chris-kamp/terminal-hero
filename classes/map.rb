require "colorize"
require_relative "tile"
require_relative "../modules/game_data"
require_relative "../classes/monster"

# Represents a map for the player to navigate
class Map
  include GameData

  attr_reader :grid, :symbols

  def initialize(player: nil, width: GameData::MAP_WIDTH, height: GameData::MAP_HEIGHT, grid: nil, monsters: [])
    # Set dimensions of map
    @width = width
    @height = height
    # Dictionary of map symbols
    @symbols = GameData::MAP_SYMBOLS
    # Array of monsters on the map
    @monsters = monsters
    if grid.nil?
      # Fill map grid with terrain tiles
      @grid = setup_grid
      # Place the Player on the map
      @grid[player.coords[:y]][player.coords[:x]].entity = player
      # Populate the map with monsters
      populate_monsters
    else
      load_map(grid, player)
    end
  end

  # Set up the map when loading from a save file
  def load_map(grid, player)
    @grid = grid.map do |row|
      row.map do |tile|
        # Convert string values generated by JSON back to symbols
        tile[:color] = tile[:color].to_sym
        tile[:event] = tile[:event].to_sym unless tile[:event].nil?
        # Map each hash of tile data to a Tile
        Tile.new(**tile)
      end
    end
    @monsters.map! do |monster_data|
      monster_data[:event] = monster_data[:event].to_sym
      monster = Monster.new(**monster_data)
      @grid[monster.coords[:y]][monster.coords[:x]].entity = monster
      monster
    end
    @grid[player.coords[:y]][player.coords[:x]].entity = player
  end


  # Given an index, a centrepoint, a radius, and a modification to the radius,
  # determine whether index false inside the radius. Used for map setup.
  def in_radius?(y_index, x_index, y_centre, x_centre, v_radius, h_radius, variance)
    ((y_centre - v_radius - variance)..(y_centre + v_radius + variance)).include?(y_index) &&
      ((x_centre - h_radius - variance)..(x_centre + h_radius + variance)).include?(x_index)
  end

  # Populate the map grid with semi-randomised terrain tiles
  def setup_grid
    # Create 2D array
    grid = []
    @height.times { grid.push(Array.new(@width, false)) }

    # Set parameters for map generation - centrepoint, base radius of map regions,
    # variance and max variance from that radius
    h_cent = @width / 2
    v_cent = @height / 2
    h_rad = @width / 8
    v_rad = @height / 8
    variance = 0
    max_variance = ([@width, @height].min) / 16

    # Populate the map grid with terrain tiles
    grid.each_with_index do |row, y|
      row.map!.with_index do |_square, x|
        # First and last row and column are edge tiles
        if y == 0 || y == @height - 1 || x == 0 || x == @width - 1
          tile = Tile.new(**@symbols[:edge])
        # Tiles inside base radius (after variance) are region 1
        elsif in_radius?(y, x, v_cent, h_cent, v_rad, h_rad, variance)
          tile = Tile.new(**@symbols[:mountain])
        # Tiles not in region 1 that are inside 2 * base radius are region 2
        elsif in_radius?(y, x, v_cent, h_cent, v_rad * 2, h_rad * 2, variance)
          tile = Tile.new(**@symbols[:forest])
        # Everything else is region 3
        else
          tile = Tile.new(**@symbols[:plain])
        end
        variance = Utils.collar(0, variance + rand(-1..1), max_variance)
        tile
      end
    end
    return grid
  end

  # Randomly populate monsters on the grid
  def populate_monsters
    # 1/60 map tiles +/- 5 will be populated with monsters
    max_monsters = [(@width * @height / 60) + rand(-5..5), 1].max
    # Populate map until max population is reached, or number of iterations equals
    # number of map tiles (preventing infinite loop if valid tile not found)
    counter = 0
    until @monsters.length >= max_monsters || counter >= @width * @height
      y = rand(1..(@height - 2))
      x = rand(1..(@width - 2))
      unless @grid[y][x].blocking
        monster = Monster.new(coords: { x: x, y: y })
        @grid[y][x].entity = monster
        @monsters.push(monster)
      end
      counter += 1
    end
  end

  # Given destination coords for movement, update the map, move the moving entity
  # and return the destination tile (or nil if destination invalid)
  def process_movement(mover, destination)
    return nil unless valid_move?(destination)

    unless @grid[destination[:y]][destination[:x]].blocking
      @grid[mover.coords[:y]][mover.coords[:x]].entity = nil
      @grid[destination[:y]][destination[:x]].entity = mover
      mover.coords = destination
    end
    return @grid[destination[:y]][destination[:x]]
  end

  # Call methods for each monster to determine the move it makes (if any) and process that movement.
  # If a monster encounters the player, return its tile to allow triggering a combat event.
  def move_monsters(player_coords)
    event_tile = nil
    @monsters.each do |monster|
      destination = monster.calc_destination(monster.choose_move(player_coords))
      process_movement(monster, destination)
      event_tile = @grid[monster.coords[:y]][monster.coords[:x]] if destination == player_coords
    end
    return event_tile
  end

  # Remove a monster from the map
  def remove_monster(monster)
    @grid[monster.coords[:y]][monster.coords[:x]].entity = nil
    @monsters.delete(monster)
  end

  # Check if coords are a valid destination within the map (but not necessarily open for movement)
  def valid_move?(coords)
    return false unless coords.is_a?(Hash)
    return false unless (0..(@width - 1)).include?(coords[:x])
    return false unless (0..(@height - 1)).include?(coords[:y])

    return true
  end

  # After combat concludes, if a monster was defeated, remove it and repopulate monsters
  def post_combat(player, monster, outcome)
    case outcome
    # Remove defeated monster from map, and repopulate monsters
    when :victory
      remove_monster(monster)
      populate_monsters
    # Move defeated player back to starting location (unless already there), swapping positions
    # with any entity that is currently occupying that location
    when :defeat
      unless player.coords.values == GameData::DEFAULT_COORDS.values
        shifted_entity = @grid[GameData::DEFAULT_COORDS[:y]][GameData::DEFAULT_COORDS[:x]].entity
        player_location = player.coords
        @grid[GameData::DEFAULT_COORDS[:y]][GameData::DEFAULT_COORDS[:x]].entity = nil
        process_movement(player, GameData::DEFAULT_COORDS)
        process_movement(shifted_entity, player_location) unless shifted_entity.nil?
      end
    end
  end

  # Export all values required for initialization to a hash, to be stored in a JSON save file
  def export
    return {
      width: @width,
      height: @height,
      grid: @grid.map do |row|
        row.map(&:export)
      end,
      monsters: @monsters.map(&:export)
    }
  end


end
